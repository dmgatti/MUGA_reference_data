---
title: "Reference Data QC: MegaMUGA"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: TRUE
    toc_depth: 3
    code_folding: hide
---

# MegaMUGA Annotations

```{r setup, echo=FALSE, include=FALSE}
knitr::opts_chunk$set(message = FALSE)
library(tidyverse)
library(data.table)
library(purrr)
library(qtl2)
library(magrittr)
library(DT)
library(plotly)
QCtheme <- theme_bw() + 
  theme(panel.grid = element_blank(),
        axis.text = element_text(colour = "black"),
        axis.title = element_text(colour = "black"))
```

## Reading in reference genotypes and metadata

First I read in the reference sample genotypes, as well as marker annotations from an [analysis](https://github.com/kbroman/MUGAarrays) previously conducted by Karl Broman, Dan Gatti, and Belinda Cornes.

```{r Reading in reference genotypes and metadata}
# Reading in "reference sample genotype data
control_genotypes <- suppressWarnings(data.table::fread("../data/MMControls/control.genotypes.csv"))
colnames(control_genotypes)[1] <- "marker"

## Reading in marker annotations
mm_metadata <- data.table::fread("../data/MMControls/mm_uwisc_v2.csv")
```

## Marker QC: Searching for missing genotype calls

We searched for probes where many mice are missing genotype calls.

```{r Markers with high "N" counts among reference samples}
## Calculating allele frequencies for each marker
control_allele_freqs <- control_genotypes %>%
  tidyr::pivot_longer(-marker, names_to = "sample", values_to = "genotype") %>%
  dplyr::group_by(marker, genotype) %>%
  dplyr::summarise(n = n()) %>%
  dplyr::mutate(freq = round(n/sum(n), 3),
                genotype = as.factor(genotype)) %>%
  dplyr::left_join(., mm_metadata)

## Filtering to markers with missing genotypes
no.calls <- control_allele_freqs %>%
  dplyr::filter(genotype == "N") %>%
  tidyr::pivot_wider(names_from = genotype, values_from = n) %>%
  dplyr::select(marker, chr, bp_grcm39, freq) %>%
  dplyr::mutate(chr = as.factor(chr))
cutoff <- quantile(no.calls$freq, probs = seq(0,1,0.05))[[20]]
above.cutoff <- no.calls %>%
  dplyr::filter(freq > cutoff)
```

Of `r length(unique(as.factor(control_allele_freqs$marker)))` markers, `r nrow(no.calls)` failed to genotype at least one sample, and `r nrow(above.cutoff)` markers failed to genotype at least `r cutoff*100`% of samples.

```{r Plotting no calls, echo=FALSE}

above.cutoff %>%
  dplyr::left_join(.,mm_metadata) %>%
  dplyr::mutate(chr = as.factor(chr)) %>%
  dplyr::arrange(marker) %>%
  DT::datatable(., filte = "top", 
              escape = FALSE, 
              options = list(columnDefs = list(list(width = '20%', targets = c(8)))))

ggplot(no.calls, mapping = aes(x = freq)) + 
  geom_histogram(bins = 100) +
  scale_x_continuous(breaks = seq(0,1,0.1)) + 
  QCtheme + 
  labs(x = "Fraction of mice with missing genotypes",
       y = "Number of markers")
```

## Sample QC: Searching for samples with poor marker representation

In a similar fashion, we calculated the number of reference samples with missing genotypes. Repeated observations of samples/strains with identical names meant that genotype counts for each marker among them couldn't be grouped and tallied, so determining no-call frequency occurred column-wise. Mouse over individual samples to see the number of markers with missing genotypes for each sample.

```{r Reference samples with high missingness}
n.calls.strains <- apply(X = control_genotypes[,2:ncol(control_genotypes)], MARGIN = 2, function(x) table(x)[5])
n.calls.strains.df <- data.frame(n.calls.strains)
n.calls.strains.df$sample <- names(n.calls.strains)
n.calls.strains.df %<>%
  dplyr::rename(n.no.calls = n.calls.strains)

sampleQC <- ggplot(n.calls.strains.df, 
                   mapping = aes(x = reorder(sample,n.no.calls), 
                                 y = n.no.calls,
                                 text = paste("Sample:", sample))) + 
  geom_point() +
  QCtheme + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) +
  labs(x = "Number of mice with missing genotypes",
       y = "Number of markers")
ggplotly(sampleQC, tooltip = c("text","y"))

high.n.samples <- n.calls.strains.df %>%
  dplyr::filter(n.no.calls > quantile(n.calls.strains.df$n.no.calls, probs = seq(0,1,0.05))[20])
```

## Validating sex of reference samples

We next validated the sexes of each sample using sex chromosome probe intensities. We paired up probe intensities, joined available metadata, and filtered down to only markers covering the X and Y chromosomes.

```{r Filtering to Chr X Markers}
## Reading in genotype intensities
x_intensities <- suppressWarnings(data.table::fread("../data/MMControls/control.X.csv"))
colnames(x_intensities)[1] <- "marker"
y_intensities <- suppressWarnings(data.table::fread("../data/MMControls/control.Y.csv"))
colnames(y_intensities)[1] <- "marker"
## Check to see if dimensions of intensity tables are identical, marker orders identical, and sample orders identical
if((unique(dim(x_intensities) == dim(y_intensities)) && 
   unique(colnames(x_intensities) == colnames(y_intensities)) &&
   unique(x_intensities$marker == y_intensities$marker)) == TRUE){
     ## Pivoting the data longer
  x_int_long <- x_intensities %>%
  tidyr::pivot_longer(cols = -marker, names_to = "sample", values_to = "x_int")
  y_int_long <- y_intensities %>%
  tidyr::pivot_longer(cols = -marker, names_to = "sample", values_to = "y_int")
  
  long_intensities <- cbind(x_int_long, y_int_long)
} else {
     print("Source intensity data frames have non-identical structure; exiting")
}

## Joining slimmer intensity files with marker metadata and reducing to Chromosome X markers
long_XY_intensities <- long_intensities[,c(1,2,3,6)] %>%
  dplyr::left_join(., mm_metadata) %>%
  dplyr::filter(chr %in% c("X","Y"))

```

Then we flagged markers with high missingness across all samples, as well as samples with high missingness among all markers.

```{r Flagging "low-quality" markers and samples}
## Flagging markers and samples based on previous QC steps
flagged_XY_intensities <- long_XY_intensities %>%
  dplyr::mutate(marker_flag = dplyr::if_else(condition = marker %in% above.cutoff$marker,
                                             true = "FLAG",
                                             false = "")) %>%
  dplyr::mutate(high_missing_sample = dplyr::if_else(condition = sample %in% high.n.samples$sample,
                                                     true = "FLAG",
                                                     false = ""))
```

The first round of inferring predicted sexes used a rough search of the sample name for expected nomenclature convention, which includes a sex denotation.

```{r Preliminary sex prediction}
## First round of predicted sex inference
prelim.predicted.sexes <- flagged_XY_intensities %>%
  dplyr::mutate(bg = dplyr::case_when(stringr::str_detect(string = sample, 
                                                          pattern = "F1") == TRUE ~ "F1",
                                      TRUE ~ as.character(sample)),
                predicted.sex = dplyr::case_when(stringr::str_detect(string = sample, 
                                                          pattern = "F1f") == TRUE ~ "f",
                                      stringr::str_detect(string = sample, 
                                                          pattern = "F1m") == TRUE ~ "m",
                                      TRUE ~ "unknown"))

unknown <- prelim.predicted.sexes %>%
  dplyr::filter(predicted.sex == "unknown")

digit.trim <- unknown %>% 
  dplyr::mutate(mouse.id.1 = stringr::str_sub(sample, -1),
                predicted.sex.1 = dplyr::case_when(stringr::str_sub(mouse.id.1, 1, 1) %in% c("m","M") ~ "m",
                                                   stringr::str_sub(mouse.id.1, 1, 1) %in% c("f","F") ~ "f",
                                                 TRUE ~ "unknown"),
                bg = if_else(condition = (predicted.sex.1 == "m" | predicted.sex.1 == "f"), 
                             true = str_replace(string = bg, 
                                                pattern = mouse.id.1, 
                                                replacement = ""), 
                             false = bg),
                
                mouse.id.3= stringr::str_sub(sample, -3),
                predicted.sex.3 = dplyr::case_when(stringr::str_sub(mouse.id.3, 1, 1) %in% c("m","M") ~ "m",
                                                 stringr::str_sub(mouse.id.3, 1, 1) %in% c("f","F") ~ "f",
                                                 TRUE ~ "unknown"),
                bg = if_else(condition = (predicted.sex.3 == "m" | predicted.sex.3 == "f"), 
                             true = str_replace(string = bg, 
                                                pattern = mouse.id.3, 
                                                replacement = ""), 
                             false = bg),
                
                mouse.id.4 = stringr::str_sub(sample, -4),
                predicted.sex.4 = dplyr::case_when(stringr::str_sub(mouse.id.4, 1, 1) %in% c("m","M") ~ "m",
                                                 stringr::str_sub(mouse.id.4, 1, 1) %in% c("f","F") ~ "f",
                                                 TRUE ~ "unknown"),
                bg = if_else(condition = (predicted.sex.4 == "m" | predicted.sex.4 == "f"), 
                             true = str_replace(string = bg, 
                                                pattern = mouse.id.4, 
                                                replacement = ""), 
                             false = bg),
                
                mouse.id.5 = stringr::str_sub(sample, -5),
                mouse.id.5 = stringr::str_replace(string = mouse.id.5,  ## a couple symbols in these ids mess up the regex search
                                                  pattern = "[:symbol:]", 
                                                  replacement = ""),
                predicted.sex.5 = dplyr::case_when(stringr::str_sub(mouse.id.5, 1, 1) %in% c("m","M") ~ "m",
                                                 stringr::str_sub(mouse.id.5, 1, 1) %in% c("f","F") ~ "f",
                                                 TRUE ~ "unknown"),
                bg = if_else(condition = (predicted.sex.5 == "m" | predicted.sex.5 == "f"),
                             true = str_replace(string = bg,
                                                pattern = mouse.id.5,
                                                replacement = ""),
                             false = bg),
                
                mouse.id.6 = stringr::str_sub(sample, -6),
                mouse.id.6 = stringr::str_replace(string = mouse.id.6,  ## a couple symbols in these ids mess up the regex search
                                                  pattern = "[:punct:]", 
                                                  replacement = ""),
                mouse.id.6 = stringr::str_replace(string = mouse.id.6,  ## a couple symbols in these ids mess up the regex search
                                                  pattern = "[:symbol:]", 
                                                  replacement = ""),
                predicted.sex.6 = dplyr::case_when(stringr::str_sub(mouse.id.6, 1, 1) %in% c("m","M") ~ "m",
                                                 stringr::str_sub(mouse.id.6, 1, 1) %in% c("f","F") ~ "f",
                                                 TRUE ~ "unknown"),
                bg = if_else(condition = (predicted.sex.6 == "m" | predicted.sex.6 == "f"), 
                             true = str_replace(string = bg, 
                                                pattern = mouse.id.6, 
                                                replacement = ""), 
                             false = bg)) %>%
  dplyr::mutate(predicted.sex = dplyr::case_when(predicted.sex.1 == "m" ~ "m", 
                                                 predicted.sex.3 == "m" ~ "m",
                                                 predicted.sex.4 == "m" ~ "m",
                                                 predicted.sex.5 == "m" ~ "m",
                                                 predicted.sex.6 == "m" ~ "m",
                                                 
                                                 predicted.sex.1 == "f" ~ "f", 
                                                 predicted.sex.3 == "f" ~ "f",
                                                 predicted.sex.4 == "f" ~ "f",
                                                 predicted.sex.5 == "f" ~ "f",
                                                 predicted.sex.6 == "f" ~ "f",
                                                 TRUE ~ "unknown"))

# Removing previously "unknown" samples from initial results and binding newly inferred samples
predicted.sexes.strings <- prelim.predicted.sexes %>%
  dplyr::filter(predicted.sex != "unknown") %>%
  dplyr::bind_rows(.,digit.trim)

## Taking the first marker as a sample and tabulating the number of samples for each predicted sex
predicted.sex.table <- predicted.sexes.strings %>%
  dplyr::filter(marker %in% unique(prelim.predicted.sexes$marker)[1]) %>%
  dplyr::select(sample, predicted.sex, bg) %>%
  dplyr::group_by(predicted.sex) %>%
  dplyr::count() 

```

This captured `r predicted.sex.table[which(predicted.sex.table$predicted.sex == "f"),2]$n` female samples, `r predicted.sex.table[which(predicted.sex.table$predicted.sex == "m"),2]$n` male samples, leaving `r predicted.sex.table[which(predicted.sex.table$predicted.sex == "unknown"),2]$n` samples of unknown predicted sex from nomenclature alone. These samples (below) exhibit a range of naming irregularities.

```{r Predicted sex table}
predicted.sexes.strings %>%
  dplyr::filter(predicted.sex == "unknown",
                marker == predicted.sexes.strings$marker[[1]]) %>%
  dplyr::select(sample, bg)
```

After predicting the sexes of the vast majority of reference samples, we visualized the average probe intensity among X Chromosome markers for each sample, labeling them by predicted sex. Samples colored black were unabled to have their sex inferred by the sample name, but cluster well with mice for which sex could be inferred. Conversely, some samples' predicted sex is discordant with X and Y Chromosome marker intensities (i.e. blue samples that cluster with mostly orange samples, and vice versa). Mouse over individual dots to view the sample, as well as whether it was flagged for having many markers with missing genotype information.

```{r Predicted sex visualization}
mean.x.intensities.by.sex <- predicted.sexes.strings %>%
  dplyr::filter(marker_flag != "FLAG") %>%
  dplyr::group_by(sample, predicted.sex, chr, high_missing_sample) %>%
  dplyr::summarise(mean.x = mean(x_int),
                   mean.y = mean(y_int))

predicted.sex.plot.palettes <- mean.x.intensities.by.sex %>%
  dplyr::ungroup() %>%
  dplyr::distinct(sample, predicted.sex, high_missing_sample) %>%
  dplyr::mutate(predicted.sex.palette = dplyr::case_when(predicted.sex == "f" ~ "#5856b7",
                                                         predicted.sex == "m" ~ "#eeb868",
                                                         predicted.sex == "unknown" ~ "black"))

predicted.sex.palette <- predicted.sex.plot.palettes$predicted.sex.palette
names(predicted.sex.palette) <- predicted.sex.plot.palettes$predicted.sex

mean.x.intensities.by.sex.plot <- ggplot(mean.x.intensities.by.sex, 
                                         mapping = aes(x = mean.x, 
                                                       y = mean.y, 
                                                       colour = predicted.sex,
                                                       shape = high_missing_sample,
                                                       text = sample,
                                                       label = high_missing_sample)) + 
  geom_point() + 
  scale_colour_manual(values = predicted.sex.palette) + 
  facet_grid(.~chr) +
  QCtheme
ggplotly(mean.x.intensities.by.sex.plot, 
         tooltip = c("text","label"),)
```

By visual inspection, we found the following issues with either the sample name-based sex prediction or putative sex mix-ups:

-   **129S1/SvImJf**: Predicted as male, plotted with females; this makes sense because following a 1 character search for sex classifier (yielding "f") is a three character search (yielding "mJf"). Might need a specific fix for this sample. Almost certainly a female that was predicted incorrectly.

-   **R26FIpe/FIpem997**: Predicted male, plotted with females. Four character search would yield proper mouse ID, but clustered stereotypically with other female samples.

-   **Nestin -/- Cre+m; TgIn -/- Cre+m**: Predicted male, plotted with females.

-   **(CAST/EiJxPWK/PhJ)F10123**: Predicted female, plotted as male. Capitalized "M" or "F" were treated with equal weight as lowercase sex classifiers in mouse ID. Specific Chr X genotypes should reveal sex (*i.e.* do Chr X calls match CAST/EiJ or PWK/PhJ sample Chr X calls?)

-   **017-FH-F1**: Predicted female, plotted as male. Capitalized "F" following five character search would have yielded this prediction. Even without proper nomenclature, the sample's stereotypical clustering would suggest this sample is male.

-   **(BALB/cByJxC57BL/6J)F1f31283; (BALB/cJxC57BL/6J)F1f36006**: Predicted female, plotted as male. Samples are from very similar strain backgrounds. Specific Chr X genotypes should reveal sex (*i.e.* do Chr X calls match BALB/cJ samples?).

In addition, all samples for which sex could not be predicted based on sample ID clustered with one sex or the other based on probe intensity, with the slight exception of IN34, which is was flagged for low marker representation.
